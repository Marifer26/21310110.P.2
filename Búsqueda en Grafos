# Definimos la estructura de datos para almacenar un borde del grafo
class Edge:
    def __init__(self, src, dest):
        # El vértice de origen (src) y el vértice de destino (dest) se asignan como atributos
        self.src = src
        self.dest = dest

# Clase para representar el grafo
class Graph:
    def __init__(self, edges, n):
        # Creamos una lista de adyacencia para el grafo
        # Cada elemento de la lista representa los vecinos de un vértice
        self.adjList = [[] for _ in range(n)]

        # Agregamos los bordes al grafo no dirigido
        for edge in edges:
            # Añadimos el vértice de destino a la lista de adyacencia del vértice de origen
            self.adjList[edge.src].append(edge.dest)
            # También agregamos el vértice de origen a la lista de adyacencia del vértice de destino
            self.adjList[edge.dest].append(edge.src)

# Función para realizar el recorrido DFS en el grafo
def DFS(graph, v, discovered):
    # Marcamos el nodo actual como descubierto
    discovered[v] = True
    # Imprimimos el nodo actual
    print(v, end=" ")

    # Exploramos los vecinos no descubiertos
    for u in graph.adjList[v]:
        if not discovered[u]:
            # Llamamos recursivamente a la función DFS para el vecino no descubierto
            DFS(graph, u, discovered)

# Ejemplo de uso
if __name__ == "__main__":
    # Creamos un grafo con 7 vértices y 8 bordes
    edges = [Edge(0, 1), Edge(0, 2), Edge(1, 3), Edge(1, 4),
             Edge(2, 5), Edge(2, 6), Edge(4, 5), Edge(5, 6)]
    n = 7
    graph = Graph(edges, n)

    # Inicializamos el arreglo de nodos descubiertos
    discovered = [False] * n

    # Realizamos el recorrido DFS desde el vértice 0
    print("Recorrido DFS desde el vértice 0:")
    DFS(graph, 0, discovered)
